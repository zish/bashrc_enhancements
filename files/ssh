#- SSH interception subroutine with a lot great extras.
# This was written originally to eliminate the need to copy or clone a custom .bashrc to remote systems,
#
# Author: Jeremy Melanson
#
# Source-code, documentation and revision Git repository: https://github.com/zish/bashrc_enhancements
#
# Author: Jeremy Melanson
#
# Last-Modified: 2016-09-08
#
# $ git clone https://github.com/zish/bashrc_enhancements
#
# To use this, source the file from your .bashrc (or .bash_profile).
#
#
# Features:
#  * Allows you to take your PS1 prompt with you.
#    - Prepends the remote prompt with "(SSH)", to visually indicate that it is an SSH session.
#  * Any aliases defined locally at run time will be defined in your remote session automatically.
#  * Select embedded functions can be cloned to your remote SSH session, by adding them to SSHI_ADD_SUBS, (defined below),
#  * Specific ranges of ines in your .bashrc can be cloned to your remote SSH session, using
#    a special '# [SSH_INCLUDE nn]' remarkbefore the lines without needing to copy them everywhere.
#
#
# This file is part of bashrc_enhancements.
#
# bashrc_enhancements is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# bashrc_enhancements is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with bashrc_enhancements.  If not, see <http://www.gnu.org/licenses/>.

#- This is similar to 'tee', but is an embedded perl script. This allows for log output filtering (TODO).
# \$mb == Maximum buffer before flushing to log file.
alias __sshi_l="perl -MIO::Handle -e '\$mb=1000;exit(1)if(!\$ARGV[0]);\$SIG{INT}=\"IGNORE\";\
 if(open(\$l,\">\",\$ARGV[0])){\$l->autoflush(1);STDOUT->autoflush(1);\
  (\$b,\$c,\$p);while(!eof (STDIN)){\$c=getc(STDIN);print \$c;\
   if(length(\$b)>=\$mb){print \$l \$b;\$b=undef;}\
   elsif(\$c eq \"\\r\"||\$c eq \"\\n\"){print \$l \$b;\$b=undef;}\
   \$b.=\$c;}close(\$l);}
 else{die(ord(7).ord(7).ord(7).\"Problem writing to \\\"\".\$ARGV[0].\"\\\":\".\$!.\"\\n\");}' --"

#- Use Perl for BASE64 encode/decode. This eliminates the need to
# keep track of different encode/decode tools and their cmd line opts.
alias __sshi_encode="perl -MMIME::Base64 -e '\$f=join(\"\",<STDIN>);print encode_base64(\$f,\"\");'"
alias __sshi_decode="perl -MMIME::Base64 -e '\$f=join(\"\",<STDIN>);print decode_base64(\$f,\"\");'"

#- Modification of anything within this section requires you to reread your rc or restart bash.
ssh(){
#- Set the configuration defaults, if no global override have been set.
# ** DO NOT MODIFY THESE DIRECTLY. THEY SHOULD BE DEFINED IN YOUR LOCAL bashrc. **
_sshi_defaults(){ local IFS=$'\n'
 while read -r L;do
  [[ "${L}" =~ ^[[:blank:]]*\# ]]&&continue #- Skip comment lines.
  [[ "${L}" =~ ^[[:blank:]]*([^\ \t\=]+)[[:blank:]]*\=[[:blank:]]*(.*) ]]&&{
   echo "[ -z \"\${${BASH_REMATCH[1]}}\" ]&&local ${BASH_REMATCH[1]}=${BASH_REMATCH[2]}";}
 done<<EOF
 SSHI_ADD_SUBS="sudo ssh tar addpath"
 SSHI_INC_FILES=()
 SSHI_INC_FILES_ARCHIVE_LOC=
 SSHI_RPS1='\[\033[1;1m\](\[\033[1;31m\]SSH\[\033[0;1m\])\[\033[0;37m\]${PS1}'
 SSHI_UC=~/.ssh/config
# SSHI_MC=/etc/ssh/ssh_config
 SSHI_LOG_BY_DEF=1
 SSHI_LOG_LOC=~/ssh_logs
 SSHI_CREATE_LOG_LOC=1
 SSHI_NO_LOG_REMOTE=1
 SSHI_LOG_COMPRESS=1
 SSHI_LOG_CMP_AGE=3
 SSHI_LOG_MIN_SIZE=512
 SSHI_LOG_CMP_BIN=gzip
 SSHI_LOG_CMP_OPTS=-9
 SSHI_SSH_BIN=/usr/bin/ssh
EOF
}

#- Format and output local error messages.
_sshi_err(){ local S="****************";echo -ne "${S}\n\a\a\aWARNING: ${1}${S}\n";}

#- Get SSH hostname and scan conf(s). Missing files are ignored.
_sshi_scancnf(){
#- $1 is user config. $2 is main conf. Rest are SSH options.
 local CF=();local OP=()
 [ -f "${1}" ]&&CF=(${1});[ -f "${2}" ]&&CF=(${CF} ${2})
 local C=0;for O in ${*};do
  [ ${C} -ge ${#CF[@]} ]&&OP=(${OP[@]} ${O});C=$((${C}+1))
 done
#- SSH Command line option knowledge.
# These are the known options for my installed OpenSSH version (v.7.2p2).
#- COMMENTS have been moved from embedded Perl, and replaced with pointers.
# This is to decrease the in-memory size of the ssh intercept function.
# BaSH Comments are omitted from in-memory, but embedded strings are left alone.
#
# POINTERS:
#  -(1)- : Opts with NO argument. ( $sw )
#  -(2)- : Opts WITH AN argument. ( $op )
#  -(3)- : Decouple user@ prefix.
#  -(4)- : Only host lines
#  -(5)- : Escape wildcard types
cat ${CF[@]}|perl -e '
 sub o{$l="local ";$r="^\\s*$_[1]";print $l.$_[0]."\n"if((!$_[1])||(grep(/$r/,@{$_[2]})));}
 $sw="^\\-[1246AaCfGgKkMNnsTtVvXxYy]";$op="^\\bcDEeFIiLlmOopQqRSWw]"; #-(1)- & -(2)-
 $sh="";while($ar=shift(@ARGV)){if($ar=~/$op/){shift(@ARGV);}elsif(!($ar=~/$sw/)){$sh=$ar;}}
 $sh=~s/^\w+\@//;o("SSH_HOST=$sh");while(<STDIN>){ #-(3)-
  $p=$_;%rt=("\\."=>"\\.","\\*"=>".*","\\?"=>"."); #-(4)-
  if($p=~/^\s*host\s+([^\#]+)\#?([^\#]*)/i){ #-(5)-
   $ch=$1;$a=$2;@h=($ch=~/([^\s\,]+)/g);foreach $H(@h){
    foreach $e(sort{$b cmp $a}(keys(%rt))){$H=~s/$e/$rt{$e}/g;} #-(6)-
    $H="^($H)\$";if($sh=~/$H/){@O=split(/\s*\,\s*/,$a);
     o("FOUND=$sh");o("LOG=1","LOG",\@O);
     o("NOLOG=1","NOLOG",\@O);o("NOPROMPT=1","NOPROMPT",\@O);
     o("PROMPTONLY=1","PROMPTONLY",\@O);exit;}}}}' -- ${OP[@]}
}

#- Clean the SSH Logs dir.
# Removes .log files smaller than ${SSHI_LOG_MIN_SIZE} and compress .log files
# older than ${SSHI_LOG_CMP_AGE}.
_sshi_clean_log_dir () { local IFS=$'\n';local CT="$(date +'%s')"
 [ -z "${SSHI_LOG_COMPRESS}" ]&&{ return;};[ ${SSHI_LOG_COMPRESS} -le 0 ]&&{ return;}
 [ -z "${SSHI_LOG_CMP_AGE}" ]&&{
  echo "SSHI_LOG_COMPRESS set, but age undefined. Cannot compress old logs."; return;}
 local F=;for F in $(find ${SSHI_LOG_LOC} -maxdepth 1 -printf "%Cs %s %p\n"|grep -e "\.log$");do
  [[ "${F}" =~ ^([0-9]+)\ ([0-9]+)\ (.*) ]]&&{ local D="$(((${CT}-${BASH_REMATCH[1]})/86400))"
   local S="${BASH_REMATCH[2]}";local L="${BASH_REMATCH[3]}";}
  [ ${D} -ge ${SSHI_LOG_CMP_AGE} ]&&{
   [ ${S} -lt ${SSHI_LOG_MIN_SIZE} ]&&{
    echo "Removing ${L} (Size is ${S} bytes. Minimum size is ${SSHI_LOG_MIN_SIZE}).";rm ${L};}||
   { echo "Compressing ${L}";${SSHI_LOG_CMP_BIN} ${SSHI_LOG_CMP_OPTS} ${L};} }
 done
}

#- Pull requested functions defined by SSHI_ADD_SUBS.
# and lines in rc file marked by [SSHI_INCLUDE XX] remarks.
_sshi_getrc(){
#- COMMENTS have been moved from embedded Perl, and replaced with pointers.
# POINTERS:
#  -(1)- : $b stands for {b}rackets.
#  -(2)- : Grab [SSHI_INCLUDE] sections in bashrc.
#          * GETS BOTH SSH_INCLUDE AND SSHI_INCLUDE. The former will be deprecated soon.
 set|/usr/bin/perl -e '$rc=shift(@ARGV);my%addSubs;foreach my$f(@ARGV){$addSubs{$f}=1;}
  my$b;foreach my$l(<STDIN>){
   if($l=~/^\s*(\S+)\s+\([^\(\)]*\)\s*$/){$b=$1;} #-(1)-
   print $l if($addSubs{$b});$b=undef if($l=~/^\}\s*([\;\#]?.*)/);}
  my$rcFh;open($rcFh,"<",$rc)||die("Cannot open rc file $rc: $!");
  my@rc=<$rcFh>;close($rcFh);
  my($i,$c,$incPos);foreach my$l(@rc){ #-(2)-
   if($l=~/^\s*\#\s*\[SSHI?_INCLUDE\]\s+(\d+)/){$i=$1;}
   if($i){if($c<=$i){print$l;$c++;}else{$c=0;$i=0;}}}' -- ${@}
}

#- TODO: Package external files for inclusion.
_sshi_package_include_files(){
 for I in "${SSHI_INC_FILES[@]}";do
  [[ ${I} =~ ^([^:]+):([^:]+)$ ]] && {
   echo -ne "\"${BASH_REMATCH[1]}\" "
   echo -ne "\"${BASH_REMATCH[2]}\" "
  }
  echo "I: ${I}";
 done;
}

#_sshi_package_include_files
#return

eval "$(_sshi_defaults)"; eval "$(_sshi_scancnf ${SSHI_UC} ${SSHI_MC} ${@})"

#- Log file name format.
local LOGFMT="${SSH_HOST}-$(date +'%Y-%m-%d_%H-%M-%S').log"
#- Determine if we should log.
[ -n "${SSHI_IS_SSH}" ]&&[ -n "${SSHI_NO_LOG_REMOTE}" ]&&{ NOLOG=1;unset LOGFILE;}||
# Log by default. Turn off logging when requested.
{ [ -n "${SSHI_LOG_BY_DEF}" ]&&{ [ -n "${NOLOG}" ]&&unset LOG NOLOG||LOG=1;}||
# Do not log by default. Turn on logging when requested.
 { [ -n "${LOG}" ]&&local LOG=1;}
#- Make sure log location is writable.
 [ -n "${LOG}" ]&&{ local LOGFILE="${SSHI_LOG_LOC}/${LOGFMT}"
 #- Create SSH log directory if needed.
  [ -n "${SSHI_LOG_LOC}" ]&&{ [ -n ${SSHI_CREATE_LOG_LOC} ]&&{ [ ! -e ${SSHI_LOG_LOC} ]&&{
   mkdir -p ${SSHI_LOG_LOC}||_sshi_err "Unable to create dir:\n   ${SSHI_LOG_LOC}.";} } }
  #- Make sure log directory is writeable.
  local ERR=
  local WT=${SSHI_LOG_LOC}/.SSHI_WRITE_OK
  rm ${WT} 2>/dev/null||ERR=$((${ERR}+1));touch ${WT} 2>/dev/null||ERR=$((${ERR}+1))
  [ -n "${ERR}" ]&&{
   _sshi_err "Unable to write to directory '${SSHI_LOG_LOC}'.\nSession will not be logged."
   unset LOGFILE;}||{ _sshi_clean_log_dir;touch ${LOGFILE};} } }

#- Skip prompt and rc file shipping if requested.
[ -n "${NOPROMPT}" ]&&unset FOUND
#- Parse things and connect if we have a matched entry in the SSH config.
[ -n "${FOUND}" ]&&{
 local SSHREMCMD= #- Holds contents of commands to run on remote host.
#- PROMPTONLY set on a host .ssh/config. Set things accordingly.
 [ -n "${PROMPTONLY}" ]&&{ [ -n "${SSHI_RPS1}" ]&&{
   echo -e "Connecting to ${FOUND} with local prompt.\n";SSHREMCMD="export PS1=\"${SSHI_RPS1}\";exec bash";}
 }||{
 #- The rcfile to use remotely. Regenerates every time you log in.
 # local .bashrc will be called at the end. Overrides can be defined on the remote.
 # This variable is exported for use on remote systems.
  [ -z "${RCPUSH}" ]&&RCPUSH=".bashrc_pushed-${USER}"
 #- Add an alias to bash (use your customized bash env).
  local USH="alias bash='/bin/bash --rcfile ~/${RCPUSH}'"
 #- Code to determine user's local RC ( ${LRC} )
  local LRC='for F in .bashrc .bash_profile .profile;do [ -e ~/${F} ]&&{ echo ${F};break;};done'
  local RBASHRC='. $('"${LRC}"');'
  [ -n "${SSHI_RPS1}" ]&&RBASHRC+="export PS1=\"${SSHI_RPS1}\""
  local RBASHRC_E
  echo -e "Connecting to ${FOUND} with local shell includes.\n"

 #- Had a problem with the embedded __sshi_l alias with older Perl versions.
 # Not going to figure it out for now.
 # We fall back to "tee -i", if the version is lower than 5.18.
  PC="perl -e 'use v5.18;' 2>/dev/null;[ \${?} -gt 0 ]&&{ echo;
   OPERL=1;echo '**** WARNING: Perl version is earlier than 5.18.     ****';
   echo '**** Using tee -i for logging (NO OUTPUT FILTERING). ****';echo;}"
  eval "${PC}"
 #- Gather aliases.
  local ALI=;local OI=${IFS};IFS=$'\n';
  for A in $(alias);do
   #- Replace the __sshi_l alias, if an old Perl version was found locally.
   [[ "${A}" =~ ^alias\ __sshi_l ]]&&{ [ -n "${OPERL}" ]&&{ A="alias __sshi_l='tee -i'";} }
   ALI="${ALI}${A};"
  done;IFS=${OI}
 #- Use RCPUSH file if in an SSH session. Allows you to reuse your shipped stuff when
 # using ssh on remote systems.
 # ** This only really matters when ssh is included in SSHI_ADD_SUBS.
 # Attempt to use pushed rc if SSH.  Use local rc if non-SSH
  local RC=;[ -n "${SSHI_IS_SSH}" ]&&[ -e "~/${RCPUSH}" ]&&{ RC="~/${RCPUSH}";echo "NN: ${RC}";}||
  { RC=~/$(eval ${LRC});}
 #- Retrieve SSHI_ADD_SUBS functions and [SSH_INCLUDE] lines.
 # Functions need to be decoded before 'source'ing them (for some reason). Decoded output is
 # piped to RCPUSH.funcs file, which is sourced from the pushed rc file.
  local RFUNCS="export RCPUSH=${RCPUSH};$(_sshi_getrc ${RC} ${SSHI_ADD_SUBS})"
  local RFUNCS_E="sleep 0.2;echo "$(echo "${RFUNCS}"|__sshi_encode)"|__sshi_decode>~/${RCPUSH}.funcs;. ~/${RCPUSH}.funcs"
  RBASHRC_E="export SSHI_IS_SSH=1;${ALI}${RFUNCS_E};${RBASHRC}"
  RBASHRC_E=${RBASHRC_E//\$/\\$};RBASHRC_E=${RBASHRC_E//\"/\\\"}
  local SSHREMCMD="echo \"${RBASHRC_E}\">~/${RCPUSH};exec bash --rcfile ~/${RCPUSH}"
 }
}
#- Compile the SSH command to run (including logging stuff) and run it.
local LC=
local SSHEXEC=("${SSHI_SSH_BIN}" ${@})
[ -n "${SSHREMCMD}" ]&&SSHEXEC=(${SSHEXEC[@]} "-t" "${SSHREMCMD}")
[ -n "${LOGFILE}" ]&&{ [ -z "${OPERL}" ]&&{ LC="__sshi_l ${LOGFILE}";}||{ LC="tee -i ${LOGFILE}";} }
[ -n "${LC}" ]&&{ ${SSHEXEC[*]}|eval ${LC};}||{ ${SSHEXEC[*]};}
#- Logging report.
echo "------------------------------------------------"
[ -n "${LOG}" ]&&{ [ -n "${LOGFILE}" ]&&{
 #- Report the log file name, if it is not zero-length. Otherwise remove the file.
 #- Report the session log path, but not if zero-length.
  [ -s "${LOGFILE}" ]&&{ echo "Session logged to ${LOGFILE}";}||
 #- Warn the user of zero-length log, and clear the file.
  { echo "No output logged from session. Removing ${LOGFILE}";rm "${LOGFILE}";}
 #- Warn the user that we were unable to write the session log.
 }||{ echo "WARNING: Logging is enabled, but unable to write to log. Verify SSHI_LOG_LOC is correct.";} }
} # END ssh

# vim: filetype=sh tabstop=1 expandtab
